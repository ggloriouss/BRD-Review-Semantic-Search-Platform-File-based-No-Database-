# Role: You are senior full stack developer and proficient with these tech stack

* Backend: Rust (axum), fastembed-rs, spfresh (C++ binding)
* Frontend: Leptos (Rust WASM/SSR)
* Data store: file index (spfresh) + file metadata (.jsonl)

# Instruction
    1. you are already have a Project structure which you cannot modify or add any file as possible.
    2. Only terminate your turn when you are sure that the problem is solved.
    3. Go through the problem step by step, and make sure to verify that your changes are correct. NEVER end your turn without having solved the problem, and when you say you are going to make a tool call, make sure you ACTUALLY make the tool call, instead of ending your turn.
    4. You MUST plan extensively before each function call, and reflect extensively on the outcomes of the previous function calls. DO NOT do this entire process by making function calls only, as this can impair your ability to solve the problem and think insightfully.

# Task: 
    1. you are assigned to Create a "BRD: Review Semantic Search Platform (File-based, No Database)"    
    2. you are strict to use only provided tech stack
    3. Understand the problem deeply. Carefully read the issue and think critically about what is required.
    4. Investigate the codebase. Explore relevant files, search for key functions, and gather context.
    5. Debug as needed. Use debugging techniques to isolate and resolve issues.

# Project structure
    ``` 
    project-root/
│
├── frontend/                  # Leptos (Rust SPA/SSR)
│   ├── src/
│   ├── Cargo.toml
│   └── ...
│
├── backend/                   # Rust (axum) + fastembed-rs + spfresh binding
│   ├── src/
│   ├── Cargo.toml
│   ├── spfresh/               # (binding หรือ submodule)
│   ├── data/                  # ← เก็บไฟล์ข้อมูล (append-only)
│   │   ├── reviews.index      # ← spfresh vector index (binary, append-only)
│   │   └── reviews.jsonl      # ← metadata: 1 review ต่อ 1 บรรทัด (JSON Lines)
│   └── ...
│
├── docker-compose.yml         # Orchestration ทั้งระบบ (no DB)
│
└── README.md
    ```
# Objective
* Create a Searching review Semantic system with Vector Search 
* All data and vector index **store as file** (no database) 
* Able to inlimited insert/append review (append vector & metadata everytime) 
* Every action (insert/search) are trigger pass frontend (Leptos) → backend (Rust/axum + fastembed-rs + spfresh)

# Concise Workflow & BRD Update
    1. Data Append Flow 
    * User can **insert new review data** continuously via web page (Frontend Leptos) 
    * Every time insert (form or upload): 
    * Frontend sends data to Backend 
    * Backend creates embedding vector from specified fields (e.g. review\_body, review\_title) with fastembed-rs 
    * **Vector and review data** will be appended to spfresh (vector store, file) and metadata (e.g. JSONL file) 
    * No deletion/overwrite — **Every insert is an append of new data** 
    * Index data grows continuously (append-only) 
    2. Search Flow 
    * Frontend (Search page) lets user enter search text 
    * Frontend sends query to backend 
    * Backend creates embedding from query → search with spfresh (vector store) 
    * Returns result as a list of similar reviews (semantic match) by mapping vector id to metadata stored in file 
    3. All API Calls via Frontend 
    * **All inserts/appends** (manual or upload) trigger through the web page 
    * **All embeddings** (reviews & queries) are done on the backend side 
    * Frontend only sends raw data/queries, no embedding itself 
    4. Key Points * **No database** Data is stored as a vector index file (spfresh) + metadata (.jsonl or other formats) 
    * Users can add unlimited new reviews, data will be **append** to the end of the index store 
    * No deletion/overwrite 
    * Embedding vector is created anew every time an insert is made 
    * The frontend system acts as a middleman for users to upload/insert/trigger everything 

# Example Usecase (User Journey) 
    1. Users enter the Index page → enter reviews/select files → press Upload 
    2. Frontend calls the API (/reviews or /reviews/bulk) 
    3. Backend does embedding & append vector/metadata (Write to file) 
    4. User goes to Search page → enter query → see the most similar review results (semantic search).

# Data Storage Concept 
* **Vector Index**: Stored at data/reviews.index with spfresh (append-only) 
* **Metadata**: Stored at data/reviews.jsonl (JSON lines) mapping to vector index respectively 
* Example 1 line in reviews.jsonl:
    ``` jsonl
        {"review_title": "Great phone", "review_body": "Battery lasts long", "product_id": "P123", "review_rating": 5}
    ```
* no database/every thing is stored in files

# docker-compose.yml (No DB)
yaml
version: "3.9"
services:
  backend:
    build: ./backend
    container_name: rust-backend
    ports:
      - "8000:8000"
    volumes:
      - ./backend/data:/app/data   # backend store index/metadata on host

  frontend:
    build: ./frontend
    container_name: leptos-frontend
    ports:
      - "3000:3000"
    volumes:
      - ./frontend:/app
    environment:
      - BACKEND_URL=http://backend:8000

# Key Points 
* Insert/append-only, new data will be added continuously (no deletion/editing) 
* No database at all 
* Mapping vector id <-> metadata line made from index sequence (0-based)